import os
import sys
import numpy as np
from scipy.interpolate import interp1d

#ZHAIRESPYTHON=os.environ["ZHAIRESPYTHON"]
#sys.path.append(ZHAIRESPYTHON)
import AiresInfoFunctions as AiresInfo
import AiresInpFunctions as AiresInp
import GetArray_GP13 as gparray #PM

from scipy.interpolate import interp1d

#this script will get as input a sry file and a skeleton file, and will produce a new input file that should produce the same shower
#for it to work, the input sry file must have been generated on a simulation with an external given seed (so that the used seed is shown in the sry, instead of "Automatic")
#there are workarrounds for this since the seed is stored in the .idf file, but you will have to implement that if you need it.

#caveats:
#         using default hard coded refraction index model (default exponential on Aires)
#         we could get this from the sry file (but then the file must contain this explicitely)


if __name__ == '__main__':

  #All ZHAireS/Aires input files can be dividied in
  #- Header (with parameters that frequently change from shower to shower: TaskName, pirmary, zenith, azimuth,energy,randomseed)
  #- Antennas (and if we have antenas, then the ZHAireS ON and TimeFresne ON)
  #- Rest of the input (all other input parameters, provided in a separate file, that must end with End)
  #so, an input file is generated by calling
  #CreateAiresInputHeader
  #Something for the antennas (CreateAiresStarShapeInp)
  #AddAiresSkeletonInp

  separatearms=False
  narms=8
  

  if np.size(sys.argv)<=11:
    print("Arguments = inputsryfile skeletonfile outputinpfile slope_alpha (deg) slope_az (deg) nant RandomFraction width mode(Linear/Quadratic/Concentrated) projection(Geometrical/Conical) gp13mode") 

  else:
    sryfile = sys.argv[1]
    skeletonfile = sys.argv[2]
    outputinp = sys.argv[3]

    alpha = float(sys.argv[4]) #in deg
    az_slope = float(sys.argv[5]) #in deg

    nantennas= int(sys.argv[6])
    fraction= float(sys.argv[7])

    width= float(sys.argv[8])
 
    mode= sys.argv[9]

    projection= sys.argv[10]
    gp13mode = int(sys.argv[11])

    Zenith=AiresInfo.GetZenithAngleFromSry(sryfile,"Aires")
    Azimuth=AiresInfo.GetAzimuthAngleFromSry(sryfile,"Aires")

    TaskName=AiresInfo.GetTaskNameFromSry(sryfile)
    TaskName="Stshp_"+TaskName

    Primary=AiresInfo.GetPrimaryFromSry(sryfile)
    Energy=AiresInfo.GetEnergyFromSry(sryfile)

    RandomSeed=AiresInfo.GetRandomSeedFromSry(sryfile)
    XmaxAltitude,distance,Xmaxx,Xmaxy,Xmaxz =AiresInfo.GetKmXmaxFromSry(sryfile) #these outputs are in km

    GroundAltitude=AiresInfo.GetGroundAltitudeFromSry(sryfile)/1000.0 #put it in km for consistency
    
    AiresVersion=AiresInfo.GetAiresVersionFromSry(sryfile)
    
    RefractionIndexModel=AiresInfo.GetAtmosphericModelFromSry(sryfile)
    
    print("AiresVersion",AiresVersion,RefractionIndexModel)
    
    print("AiresVersion",AiresVersion)
    if(AiresVersion=="19.04.06" and RefractionIndexModel=='Glasgow-Dale'):   
      DensityTable=AiresInfo.GetLongitudinalTable(os.path.dirname(sryfile),"0100",Slant=False,Precision="Double",tablecolx=1,tablecoly=3)
      MassTable=AiresInfo.GetLongitudinalTable(os.path.dirname(sryfile),"0100",Slant=False,Precision="Double",tablecolx=1,tablecoly=2)      
      densityfunction = interp1d(DensityTable[:,0],DensityTable[:,1], kind='cubic')
      depthfunction = interp1d(MassTable[:,0],MassTable[:,1], kind='cubic')
      print("density at 1010",densityfunction(1010),"depth",depthfunction(1010))

    if(Xmaxx==-1.0 and Xmaxy==-1.0 and Xmaxz==-1.0):
      print("warning, could not generate starshape {0}, shower maximum not found or too low: {1:.2f}".format(outputinp,XmaxAltitude))

    #we have the cone vertex distance
    cone_vertex= np.sqrt(Xmaxx*Xmaxx+Xmaxy*Xmaxy+(Xmaxz-GroundAltitude)*(Xmaxz-GroundAltitude)) 
    #width=width-2*np.sqrt(cone_vertex)/10

    #logenergy=np.log10(Energy)
    #if(logenergy<-1.8):
    #  logenergy=-1.8
    #width=width-2*np.sqrt(cone_vertex)/10 + (5.5+3*logenergy)/(cone_vertex/5 + 1) + logenergy/2

    #we have the index of refraciton at the maximum
    #ns=  325.0    kr=  -0.12180 km^-1 is the default atmospheric model  Refractiviry=ns*exp(kr*h)  n=1.d0+1.d-6*Refractivity
    
    if(AiresVersion=="19.04.06" and RefractionIndexModel=='Glasgow-Dale'):
      GDFactor=222.97
      print("GenerateStarshapeFromShower: Warning, hard-coded glasgow dale model and constant!!",GDFactor)
      n_xmax=AiresInfo.GetRefractionIndexFromDensityFunction(XmaxAltitude*1000,densityfunction,GDFactor)
      
      #print("n_xmax",n_xmax,"N",(n_xmax-1)*1E6,"density",densityfunction(XmaxAltitude*1000),"altitude",XmaxAltitude*1000)
      r1=np.array((Xmaxx*1000,Xmaxy*1000,Xmaxz*1000))
      r2=np.array((0,0,GroundAltitude*1000)) 
      #print("n_eff",0,r1,r2,Xmaxx,Xmaxy,Xmaxz)   
      n_eff=AiresInfo.GetSmartEffectiveRefractionIndexFromDensityFunction(r1,r2,densityfunction,depthfunction,GDFactor,GroundAltitude*1000)
      #print("n_eff",n_eff,r1,r2,Xmaxx,Xmaxy,Xmaxz)        
    else:
        print("New:GenerateStarshapeFromShower: Warning, hard-coded Exponential atmospheric index of refraction model from GDAS fit!")
        ns= float(274.0) #float(325)
        kr= float(-0.11136)#float(-0.1218)
        n_xmax=1.0+1.0E-6*ns*np.exp(kr*XmaxAltitude)
        n_eff= AiresInfo.GetEffectiveRefractionIndex(Xmaxx*1000.0,Xmaxy*1000.0,Xmaxz*1000.0,ns,kr,GroundAltitude*1000.0)

    print("n",n_xmax,n_eff)

    #we have the cherenkov angle at the maximum
    theta_ch=np.arccos(1./n_xmax)*180.0/np.pi
    theta_eff=np.arccos(1./n_eff)*180.0/np.pi
    print("ch",theta_ch,theta_eff)
    #print(theta_ch,GroundAltitude,XmaxAltitude,distance,Xmaxx,Xmaxy,Xmaxz,cone_vertex,n_xmax)


    if(separatearms):
     outputinps=[]
     separatearm=range(0,narms)
     TaskNames=[]
     for i in range(0,narms):
       outputinps.append(outputinp[0:-4]+str(i)+".inp")
       TaskNames.append(TaskName+"-"+str(i))
       print(outputinps[i],separatearm[i],TaskName[i])
       
    else:
     outputinps=[outputinp]
     separatearm=[None]
     TaskNames=[TaskName]
     
    for outputinp,arm,TaskName in zip(outputinps,separatearm,TaskNames):

      file= open(outputinp,"w")
      file.write('####################################################################################\n')
      file.write('# Inputfile Generated with GenerateStarshapeFromShower:\n')
      file.write('# sry file: {0}\n'.format(sryfile))
      file.write('# skeleton file: {0}\n'.format(skeletonfile))
      file.write('# maximum was at an altitude of {0:.3} Km in ({1:.3f},{2:.3f},{3:.3f})\n'.format(XmaxAltitude,Xmaxx,Xmaxy,Xmaxz))
      file.write('# computed refractivity at emision: {0:.4f} cherenkov angle: {1:.4f} deg\n'.format((n_xmax-1)*1E6,theta_ch))
      file.write('# effective refractivity to origin: {0:.4f} cherenkov angle: {1:.4f} deg\n'.format((n_eff-1)*1E6,theta_eff))
      if(mode == "Linear" or mode == "linear"):
        file.write('# Generating a linear starshape width of {0:.2f} times the effective cherenkov cone\n'.format(width))
      elif(mode == "Quadratic" or mode == "quadratic"):
        file.write('# Generating a quadratic starshape width of {0:.2f} times the effective cherenkov cone\n'.format(width))
      elif(mode == "Concentrated" or mode == "concentrated"):
        file.write('# Generating a starshape concentrated on the cherenkov cone, using the cherenkov angle at emisison\n'.format(theta_ch))
      else:
        file.write('#WARNING Invalid starshpe mode!{0:s} \n'.format(mode))    
      file.write('# at a distance of {0:.2f} km\n'.format(cone_vertex))    
      #file.write('# using the distance to xmax and the energy to adjust the input width: inputwidth-2*np.sqrt(dist[km])/10 + 5.5+3*log10(E[EeV]))/(dist[km]/5 + 1) + log10(E[EeV])/2\n')
      file.write('####################################################################################\n')
      file.close()



      #print "****Shower direction (zen, az) = ("+str(Zenith)+','+str(Azimuth) +") deg, Mountain slope = "+str(alpha)+","+str(az_slope)+" deg"


      #CreateAiresInputHeader(TaskName, Primary, Zenith, Azimuth, Energy, RandomSeed=0, OutputFile="TestInput.inp", OutMode="a" ):
      AiresInp.CreateAiresInputHeader(TaskName, Primary, Zenith, Azimuth, Energy, RandomSeed, outputinp)

      #CreateAiresStarShapeInp(zenith, azimuth, alpha, az_slope, cone_vertex=100000.0, cone_ang=2.0, nant=20, az_B=0.0, zen_B=147.3, outputfile="TestInput.inp", outmode="a", RandomFraction = 0):
      #CreateAiresStarShapeInp(zenith, azimuth, alpha, az_slope, cone_vertex=100000.0, cone_ang=2.0, nant=20, narms=8, separatearm=None, az_B=0.0, zen_B=147.4, outputfile="TestInput.inp", outmode="a", RandomFraction = 0, stepmode="linear", projection="Geometric",vspread=0,tmin="Auto",tmax="Auto"):


      fieldintensity,fieldinclination,fielddeclination = AiresInfo.GetMagneticFieldFromSry(sryfile)

      print("using field from sry, assuming shower azimuth is magnetic:", fieldintensity, fieldinclination, fielddeclination)
      
      print("separatearm:",arm)

      #CreateAiresStarShapeInp(zenith, azimuth, alpha, az_slope, cone_vertex=100000.0, cone_ang=2.0, nant=20, az_B=0.0, zen_B=147.3, outputfile="TestInput.inp", outmode="a", RandomFraction = 0):
      if(mode == 'Linear' or mode == 'linear'):
        AiresInp.CreateAiresStarShapeInp(Zenith, Azimuth, alpha, az_slope, cone_vertex=cone_vertex*1000.0, cone_ang=width*theta_eff, nant=nantennas, narms=narms, separatearm=arm, az_B=0.0, zen_B= fieldinclination + 90, outputfile=outputinp, RandomFraction=fraction, stepmode=mode, projection=projection,vspread=1000)
      elif(mode == "Quadratic" or mode == "quadratic"):
        AiresInp.CreateAiresStarShapeInp(Zenith, Azimuth, alpha, az_slope, cone_vertex=cone_vertex*1000.0, cone_ang=width*theta_eff, nant=nantennas, narms=narms, separatearm=arm, az_B=0.0, zen_B= fieldinclination + 90, outputfile=outputinp, RandomFraction=fraction, stepmode=mode, projection=projection,vspread=1000)
      elif(mode == 'Concentrated' or mode == 'concentrated'):
        AiresInp.CreateAiresStarShapeInp(Zenith, Azimuth, alpha, az_slope, cone_vertex=cone_vertex*1000.0, cone_ang=theta_ch, nant=nantennas, narms=narms, separatearm=arm, az_B=0.0, zen_B= fieldinclination + 90, outputfile=outputinp, RandomFraction=fraction, stepmode=mode, projection=projection,vspread=1000,tmin=-75,tmax=550)
      else:
        print("Generate mode is not understood",mode,type(mode))
        

      # Add GP13 antennas , added by PM
      
      if(gp13mode ==1):
        core, ant_pos = gparray.get_gp13('gp13_new.dat')
        
        AntennaNames= []
        for k in np.arange(1,14):
            AntennaNames.append("GP"+str(k))
        #print ('Adding GP13 antennas ..............')
        AiresInp.CreateAiresAntennaListInp(ant_pos,outputinp,AntennaNames,AntennaSelection="all")
        
        
        file= open(outputinp,"a")
        file.write('#Core Position: {0:.3f} {1:.3f} {2:.3f}\n'.format(core[0],core[1],core[2]))
        file.close()
      
      #put the skeleton on it
      file= open(outputinp,"a")
      file.write('#Skeleton ##############################################################\n')
      file.close()

      fin = open(skeletonfile, "r")
      data = fin.read()
      fin.close()
      fout = open(outputinp, "a")
      fout.write(data)
      fout.close()




